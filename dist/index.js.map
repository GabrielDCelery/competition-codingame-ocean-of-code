{"version":3,"sources":["../../src/graph.ts","../../src/game-map.ts","../../src/command-interpreter.ts","../../src/constants.ts","../../src/phantom-submarine-tracker.ts","../../src/my-submarine.ts","../../../src/actions/base-action.ts","../../../src/actions/torpedo.ts","../../../src/actions/surface.ts","../node_modules/heap/lib/heap.js","../node_modules/heap/index.js","../node_modules/pathfinding/src/core/Node.js","../node_modules/pathfinding/src/core/DiagonalMovement.js","../node_modules/pathfinding/src/core/Grid.js","../node_modules/pathfinding/src/core/Util.js","../node_modules/pathfinding/src/core/Heuristic.js","../node_modules/pathfinding/src/finders/AStarFinder.js","../node_modules/pathfinding/src/finders/BestFirstFinder.js","../node_modules/pathfinding/src/finders/BreadthFirstFinder.js","../node_modules/pathfinding/src/finders/DijkstraFinder.js","../node_modules/pathfinding/src/finders/BiAStarFinder.js","../node_modules/pathfinding/src/finders/BiBestFirstFinder.js","../node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js","../node_modules/pathfinding/src/finders/BiDijkstraFinder.js","../node_modules/pathfinding/src/finders/IDAStarFinder.js","../node_modules/pathfinding/src/finders/JumpPointFinderBase.js","../node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js","../node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js","../node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js","../node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js","../node_modules/pathfinding/src/finders/JumpPointFinder.js","../node_modules/pathfinding/src/PathFinding.js","../node_modules/pathfinding/index.js","../../../src/actions/move.ts","../../../src/actions/index.ts","../../src/ai.ts","../../src/index.ts"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"../temp/src","sourcesContent":["export enum EDirection {\n  N = 'N',\n  S = 'S',\n  W = 'W',\n  E = 'E',\n}\n\nexport interface ICoordinates {\n  x: number;\n  y: number;\n}\n\nexport interface IVector {\n  x: number;\n  y: number;\n}\n\nconst vectors = {\n  UP: { x: 0, y: -1 },\n  DOWN: { x: 0, y: 1 },\n  LEFT: { x: -1, y: 0 },\n  RIGHT: { x: 1, y: 0 },\n};\n\nconst directionToVectorTransformations = {\n  [EDirection.N]: vectors.UP,\n  [EDirection.S]: vectors.DOWN,\n  [EDirection.W]: vectors.LEFT,\n  [EDirection.E]: vectors.RIGHT,\n};\n\nclass Graph {\n  transformDirectionToVector(direction: EDirection): IVector {\n    return directionToVectorTransformations[direction];\n  }\n\n  transformVectorToDirection({ x, y }: IVector): EDirection {\n    if (x === vectors.UP.x && y === vectors.UP.y) {\n      return EDirection.N;\n    }\n\n    if (x === vectors.DOWN.x && y === vectors.DOWN.y) {\n      return EDirection.S;\n    }\n\n    if (x === vectors.LEFT.x && y === vectors.LEFT.y) {\n      return EDirection.W;\n    }\n\n    if (x === vectors.RIGHT.x && y === vectors.RIGHT.y) {\n      return EDirection.E;\n    }\n\n    throw new Error(`Invalid vector transformation -> ${{ x, y }}`);\n  }\n\n  addVectorToCoordinates = ({\n    coordinates,\n    vector,\n  }: {\n    coordinates: ICoordinates;\n    vector: IVector;\n  }): ICoordinates => {\n    return {\n      x: coordinates.x + vector.x,\n      y: coordinates.y + vector.y,\n    };\n  };\n\n  createVectorFromCoordinates({\n    source,\n    target,\n  }: {\n    source: ICoordinates;\n    target: ICoordinates;\n  }): IVector {\n    return {\n      x: target.x - source.x,\n      y: target.y - source.y,\n    };\n  }\n\n  getDistanceBetweenCoordinates = (\n    coordinatesOne: ICoordinates,\n    coordinatesTwo: ICoordinates\n  ): number => {\n    const distX = Math.abs(coordinatesOne.x - coordinatesTwo.x);\n    const distY = Math.abs(coordinatesOne.y - coordinatesTwo.y);\n\n    return distX + distY;\n  };\n\n  getNeighbouringCells(coordinates: ICoordinates): ICoordinates[] {\n    const { UP, DOWN, LEFT, RIGHT } = vectors;\n    return [\n      this.addVectorToCoordinates({ coordinates, vector: UP }),\n      this.addVectorToCoordinates({ coordinates, vector: DOWN }),\n      this.addVectorToCoordinates({ coordinates, vector: LEFT }),\n      this.addVectorToCoordinates({ coordinates, vector: RIGHT }),\n    ];\n  }\n\n  getNeighbouringCellsIncludingDiagonal(coordinates: ICoordinates): ICoordinates[] {\n    const { UP, DOWN, LEFT, RIGHT } = vectors;\n    const coordinatesUp = this.addVectorToCoordinates({ coordinates, vector: UP });\n    const coordinatesDown = this.addVectorToCoordinates({ coordinates, vector: DOWN });\n    return [\n      coordinatesUp,\n      this.addVectorToCoordinates({ coordinates: coordinatesUp, vector: LEFT }),\n      this.addVectorToCoordinates({ coordinates: coordinatesUp, vector: RIGHT }),\n      coordinatesDown,\n      this.addVectorToCoordinates({ coordinates: coordinatesDown, vector: LEFT }),\n      this.addVectorToCoordinates({ coordinates: coordinatesDown, vector: RIGHT }),\n      this.addVectorToCoordinates({ coordinates, vector: LEFT }),\n      this.addVectorToCoordinates({ coordinates, vector: RIGHT }),\n    ];\n  }\n\n  transformCoordinatesToKey({ x, y }: ICoordinates): string {\n    return `${x}_${y}`;\n  }\n\n  transformKeyToCoordinates(key: string): ICoordinates {\n    const [x, y] = key.split('_').map(elem => parseInt(elem, 10));\n\n    return { x, y };\n  }\n\n  isCoordinatesInCoordinatesList(\n    coordinates: ICoordinates,\n    coordinatesList: ICoordinates[]\n  ): boolean {\n    for (let i = 0, iMax = coordinatesList.length; i < iMax; i++) {\n      if (coordinates.x === coordinatesList[i].x && coordinates.y === coordinatesList[i].y) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  getCoordinatesAtSpecificDistance({\n    coordinates,\n    distance,\n  }: {\n    coordinates: ICoordinates;\n    distance: number;\n  }): ICoordinates[] {\n    const { x, y } = coordinates;\n    const cellsAtDistance: ICoordinates[] = [];\n\n    for (\n      let offsetX = -Math.abs(distance), offsetXMax = distance;\n      offsetX <= offsetXMax;\n      offsetX++\n    ) {\n      for (\n        let offsetY = -Math.abs(distance), offsetYMax = distance;\n        offsetY <= offsetYMax;\n        offsetY++\n      ) {\n        if (Math.abs(offsetX) + Math.abs(offsetY) === distance) {\n          cellsAtDistance.push({ x: x + offsetX, y: y + offsetY });\n        }\n      }\n    }\n\n    return cellsAtDistance;\n  }\n}\n\nexport default new Graph();\n","import graph, { ICoordinates } from './graph';\n\nexport enum ETerrain {\n  WATER,\n  ISLAND,\n}\n\nexport enum EWalkabilityType {\n  WALKABLE = 0,\n  NON_WALKABLE = 1,\n}\n\nexport interface IDimensions {\n  width: number;\n  height: number;\n}\n\nconst gameInputToCellTransformations: { [index: string]: ETerrain } = {\n  '.': ETerrain.WATER,\n  x: ETerrain.ISLAND,\n};\n\nexport class GameMap {\n  private width: number;\n  private height: number;\n  private sectorSize: number;\n  private grid: Array<Array<[ETerrain, boolean]>>;\n\n  constructor({\n    width,\n    height,\n    sectorSize,\n  }: {\n    width: number;\n    height: number;\n    sectorSize: number;\n  }) {\n    this.width = width;\n    this.height = height;\n    this.sectorSize = sectorSize;\n    this.grid = new Array(this.width).fill(null).map(() => new Array(this.height).fill(null));\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        this.grid[x][y] = [ETerrain.WATER, false];\n      }\n    }\n  }\n\n  static transformGameInputToTerrain(cell: string): ETerrain {\n    return gameInputToCellTransformations[cell];\n  }\n\n  static createInstance({\n    width,\n    height,\n    sectorSize,\n  }: {\n    width: number;\n    height: number;\n    sectorSize: number;\n  }): GameMap {\n    return new GameMap({ width, height, sectorSize });\n  }\n\n  cloneGameMap(): GameMap {\n    const clonedGameMap = new GameMap({\n      width: this.width,\n      height: this.height,\n      sectorSize: this.sectorSize,\n    });\n\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        const [terrain, hasBeenVisited] = this.grid[x][y];\n        const coordinates = { x, y };\n\n        clonedGameMap\n          .setCellTerrain({ terrain, coordinates })\n          .setCellHasBeenVisited({ hasBeenVisited, coordinates });\n      }\n    }\n\n    return clonedGameMap;\n  }\n\n  getDimensions(): IDimensions {\n    return { width: this.width, height: this.height };\n  }\n\n  setCellTerrain({ terrain, coordinates }: { terrain: ETerrain; coordinates: ICoordinates }): this {\n    const { x, y } = coordinates;\n\n    this.grid[x][y][0] = terrain;\n\n    return this;\n  }\n\n  setCellHasBeenVisited({\n    hasBeenVisited,\n    coordinates,\n  }: {\n    hasBeenVisited: boolean;\n    coordinates: ICoordinates;\n  }): this {\n    const { x, y } = coordinates;\n    this.grid[x][y][1] = hasBeenVisited;\n\n    return this;\n  }\n\n  resetHaveBeenVisitedCells(): this {\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        this.setCellHasBeenVisited({ hasBeenVisited: false, coordinates: { x, y } });\n      }\n    }\n\n    return this;\n  }\n\n  areCoordinatesWithinBoundaries({ x, y }: ICoordinates): boolean {\n    return -1 < x && x < this.width && -1 < y && y < this.height;\n  }\n\n  isCellWalkable({ x, y }: ICoordinates): boolean {\n    if (this.areCoordinatesWithinBoundaries({ x, y }) === false) {\n      return false;\n    }\n\n    const [terrain, hasBeenVisited] = this.grid[x][y];\n\n    if (terrain === ETerrain.ISLAND) {\n      return false;\n    }\n\n    if (hasBeenVisited === true) {\n      return false;\n    }\n\n    return true;\n  }\n\n  getWalkableCoordinates(): ICoordinates[] {\n    const coordinates: ICoordinates[] = [];\n\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        if (this.isCellWalkable({ x, y })) {\n          coordinates.push({ x, y });\n        }\n      }\n    }\n\n    return coordinates;\n  }\n\n  getSectorForCoordinates({ x, y }: ICoordinates): number {\n    const numOfSectorsX = this.width / this.sectorSize;\n    const sectorX = Math.floor(x / this.sectorSize);\n    const sectorY = Math.floor(y / this.sectorSize);\n\n    return sectorX + 1 + numOfSectorsX * sectorY;\n  }\n\n  private processCoordinatesForReachibility({\n    coordinates,\n    distance,\n    maxDistance,\n    reachableCoordinates,\n    visitedCells,\n  }: {\n    coordinates: ICoordinates;\n    distance: number;\n    maxDistance: number;\n    reachableCoordinates: ICoordinates[];\n    visitedCells: { [index: string]: boolean };\n  }): void {\n    const { x, y } = coordinates;\n\n    reachableCoordinates.push({ x, y });\n    visitedCells[graph.transformCoordinatesToKey(coordinates)] = true;\n\n    if (distance === maxDistance) {\n      return;\n    }\n\n    graph.getNeighbouringCells(coordinates).forEach(neighbourCoordinates => {\n      if (this.areCoordinatesWithinBoundaries(neighbourCoordinates) === false) {\n        return;\n      }\n\n      const terrain = this.grid[neighbourCoordinates.x][neighbourCoordinates.y][0];\n\n      if (terrain === ETerrain.ISLAND) {\n        return;\n      }\n\n      if (visitedCells[graph.transformCoordinatesToKey(neighbourCoordinates)] === true) {\n        return;\n      }\n\n      return this.processCoordinatesForReachibility({\n        coordinates: neighbourCoordinates,\n        distance: distance + 1,\n        maxDistance,\n        reachableCoordinates,\n        visitedCells,\n      });\n    });\n  }\n\n  getReachableCoordinatesAtDistance({\n    coordinates,\n    maxDistance,\n  }: {\n    coordinates: ICoordinates;\n    maxDistance: number;\n  }): ICoordinates[] {\n    const reachableCoordinates: ICoordinates[] = [];\n    const visitedCells: { [index: string]: boolean } = {};\n\n    this.processCoordinatesForReachibility({\n      coordinates,\n      distance: 0,\n      maxDistance,\n      reachableCoordinates,\n      visitedCells,\n    });\n\n    return reachableCoordinates;\n  }\n\n  getPathFindingWalkabilityMatrix(): Array<Array<number>> {\n    const matrix = new Array(this.height).fill(null).map(() => new Array(this.width).fill(null));\n\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        matrix[y][x] = this.isCellWalkable({ x, y }) ? 0 : 1;\n      }\n    }\n\n    return matrix;\n  }\n}\n\nexport default GameMap;\n","import graph, { EDirection, ICoordinates, IVector } from './graph';\nimport { IWeightedAction } from './actions';\nimport MySubmarine from './my-submarine';\n\nexport enum ECommand {\n  NA = 'NA',\n  MOVE = 'MOVE',\n  SURFACE = 'SURFACE',\n  TORPEDO = 'TORPEDO',\n}\n\nexport interface DoNothingCommand {\n  type: ECommand.NA;\n}\n\nexport interface IMoveCommand {\n  type: ECommand.MOVE;\n  vector: IVector;\n}\n\nexport interface ISurfaceCommand {\n  type: ECommand.SURFACE;\n  sector: number;\n}\n\nexport interface ITorpedoCommand {\n  type: ECommand.TORPEDO;\n  coordinates: ICoordinates;\n}\n\nexport type TCommand = DoNothingCommand | IMoveCommand | ISurfaceCommand | ITorpedoCommand;\n\nconst COMMANDS_DELIMITER = '|';\nconst COMMAND_PARAMS_DELIMITER = ' ';\n\nclass CommandInterpreter {\n  private transformCommandStringToCommand(commandString: string): TCommand {\n    const [command, ...params] = commandString\n      .split(COMMAND_PARAMS_DELIMITER)\n      .map(elem => elem.trim());\n\n    switch (command) {\n      case ECommand.NA: {\n        return { type: ECommand.NA };\n      }\n\n      case ECommand.MOVE: {\n        const direction = params[0] as EDirection;\n        return {\n          type: ECommand.MOVE,\n          vector: graph.transformDirectionToVector(direction),\n        };\n      }\n\n      case ECommand.SURFACE: {\n        return {\n          type: ECommand.SURFACE,\n          sector: parseInt(params[0]),\n        };\n      }\n\n      case ECommand.TORPEDO: {\n        const [x, y] = params.map(elem => parseInt(elem, 10));\n        return {\n          type: ECommand.TORPEDO,\n          coordinates: { x, y },\n        };\n      }\n\n      default: {\n        console.error(`Could not process command -> ${command}`);\n      }\n    }\n\n    throw new Error(`Could not process command -> ${command}`);\n  }\n\n  transformCommandsStringToCommands(opponentCommandsString: string): TCommand[] {\n    return opponentCommandsString.split(COMMANDS_DELIMITER).map(commandString => {\n      return this.transformCommandStringToCommand(commandString.trim());\n    });\n  }\n\n  transformCommandsToCommandString({\n    commands,\n    mySubmarine,\n  }: {\n    commands: IWeightedAction[];\n    mySubmarine: MySubmarine;\n  }): string {\n    const [command] = commands;\n    const { type, parameters } = command;\n\n    switch (type) {\n      case ECommand.NA: {\n        mySubmarine.getGameMap().resetHaveBeenVisitedCells();\n        return `${ECommand.SURFACE}`;\n      }\n\n      case ECommand.MOVE: {\n        const myLocation = mySubmarine.getPosition();\n        mySubmarine\n          .getGameMap()\n          .setCellHasBeenVisited({ hasBeenVisited: true, coordinates: myLocation });\n\n        return `${ECommand.MOVE} ${parameters.direction} ${parameters.chargeCommand}`;\n      }\n\n      case ECommand.SURFACE: {\n        mySubmarine.getGameMap().resetHaveBeenVisitedCells();\n        return `${ECommand.SURFACE}`;\n      }\n\n      case ECommand.TORPEDO: {\n        return `${ECommand.TORPEDO} ${parameters.coordinates.x} ${parameters.coordinates.y}`;\n      }\n\n      default: {\n        console.error(`Could not process command -> ${command}`);\n      }\n    }\n\n    throw new Error(`Could not process command -> ${command}`);\n  }\n}\n\nexport default new CommandInterpreter();\n","export const CONST_TORPEDO_RANGE = 4;\nexport const CONST_TORPEDO_DAMAGE = 2;\nexport const CONST_SUBMARINE_HEALTH = 6;\n","import {\n  ECommand,\n  IMoveCommand,\n  ISurfaceCommand,\n  ITorpedoCommand,\n  TCommand,\n} from './command-interpreter';\nimport GameMap from './game-map';\nimport graph, { ICoordinates } from './graph';\nimport { CONST_TORPEDO_RANGE } from './constants';\n\nclass PhantomSubmarine {\n  private position: ICoordinates;\n  private gameMap: GameMap;\n\n  getPosition(): ICoordinates {\n    const { x, y } = this.position;\n\n    return { x, y };\n  }\n\n  setPosition({ x, y }: ICoordinates): this {\n    this.position = { x, y };\n\n    return this;\n  }\n\n  setGameMap(gameMap: GameMap): this {\n    this.gameMap = gameMap;\n\n    return this;\n  }\n\n  validateAndActionCommand(command: TCommand): boolean {\n    const { type } = command;\n\n    switch (type) {\n      case ECommand.NA: {\n        return true;\n      }\n\n      case ECommand.MOVE: {\n        const { vector } = command as IMoveCommand;\n\n        const newPosition = graph.addVectorToCoordinates({\n          coordinates: this.position,\n          vector,\n        });\n\n        if (!this.gameMap.isCellWalkable(newPosition)) {\n          return false;\n        }\n\n        this.gameMap.setCellHasBeenVisited({ hasBeenVisited: true, coordinates: this.position });\n        this.setPosition(newPosition);\n\n        return true;\n      }\n\n      case ECommand.SURFACE: {\n        const { sector } = command as ISurfaceCommand;\n        const submarineSector = this.gameMap.getSectorForCoordinates(this.position);\n\n        if (sector !== submarineSector) {\n          return false;\n        }\n\n        this.gameMap.resetHaveBeenVisitedCells();\n\n        return true;\n      }\n\n      case ECommand.TORPEDO: {\n        const { coordinates } = command as ITorpedoCommand;\n        const distance = graph.getDistanceBetweenCoordinates(this.position, coordinates);\n\n        if (CONST_TORPEDO_RANGE < distance) {\n          return false;\n        }\n\n        return true;\n      }\n\n      default: {\n        console.error(`Could not process command -> ${type}`);\n      }\n    }\n\n    throw new Error(`Could not process command -> ${type}`);\n  }\n}\n\nexport class PhantomSubmarineTracker {\n  private life: number;\n  private phantomSubmarines: PhantomSubmarine[];\n  private possibleLocationsMap: { [index: string]: boolean } = {};\n  private gameMap: GameMap;\n\n  constructor({ gameMap }: { gameMap: GameMap }) {\n    this.phantomSubmarines = [];\n    this.possibleLocationsMap = {};\n    this.gameMap = gameMap;\n    const { width, height } = this.gameMap.getDimensions();\n\n    for (let x = 0; x < width; x++) {\n      for (let y = 0; y < height; y++) {\n        if (this.gameMap.isCellWalkable({ x, y })) {\n          const phantomSubmarine = new PhantomSubmarine()\n            .setGameMap(this.gameMap.cloneGameMap())\n            .setPosition({ x, y });\n          this.phantomSubmarines.push(phantomSubmarine);\n          this.possibleLocationsMap[graph.transformCoordinatesToKey({ x, y })] = true;\n        }\n      }\n    }\n  }\n\n  static createInstance({ gameMap }: { gameMap: GameMap }): PhantomSubmarineTracker {\n    return new PhantomSubmarineTracker({ gameMap });\n  }\n\n  getOpponentLife(): number {\n    return this.life;\n  }\n\n  setOpponentLife(opponentLife: number): this {\n    this.life = opponentLife;\n\n    return this;\n  }\n\n  getPossibleLocationsMap(): { [index: string]: boolean } {\n    return this.possibleLocationsMap;\n  }\n\n  processCommandsForSubmarines(commands: TCommand[]): this {\n    const filteredPhantomSubmarines: PhantomSubmarine[] = [];\n    const possibleLocationsMap: { [index: string]: boolean } = {};\n\n    this.phantomSubmarines.forEach(phantomSubmarine => {\n      for (let i = 0, iMax = commands.length; i < iMax; i++) {\n        const command = commands[i];\n        const isCommandValid = phantomSubmarine.validateAndActionCommand(command);\n\n        if (!isCommandValid) {\n          return;\n        }\n      }\n\n      filteredPhantomSubmarines.push(phantomSubmarine);\n      possibleLocationsMap[graph.transformCoordinatesToKey(phantomSubmarine.getPosition())] = true;\n    });\n\n    this.phantomSubmarines = filteredPhantomSubmarines;\n    this.possibleLocationsMap = possibleLocationsMap;\n\n    return this;\n  }\n}\n\nexport default PhantomSubmarineTracker;\n","import GameMap from './game-map';\nimport { ICoordinates } from './graph';\n\nclass MySubmarine {\n  private position: ICoordinates;\n  private life: number;\n  private torpedoCooldown: number;\n  private sonarCooldown: number;\n  private silenceCooldown: number;\n  private mineCooldown: number;\n  private gameMap: GameMap;\n\n  constructor({ gameMap }: { gameMap: GameMap }) {\n    this.gameMap = gameMap;\n  }\n\n  static createInstance({ gameMap }: { gameMap: GameMap }): MySubmarine {\n    return new MySubmarine({ gameMap });\n  }\n\n  getLife(): number {\n    return this.life;\n  }\n\n  getPosition(): ICoordinates {\n    const { x, y } = this.position;\n\n    return { x, y };\n  }\n\n  getGameMap(): GameMap {\n    return this.gameMap;\n  }\n\n  isTorpedoReady(): boolean {\n    return this.torpedoCooldown === 0;\n  }\n\n  setPosition({ x, y }: ICoordinates): this {\n    this.position = { x, y };\n\n    return this;\n  }\n\n  setState({\n    x,\n    y,\n    myLife,\n    torpedoCooldown,\n    sonarCooldown,\n    silenceCooldown,\n    mineCooldown,\n  }: {\n    x: number;\n    y: number;\n    myLife: number;\n    torpedoCooldown: number;\n    sonarCooldown: number;\n    silenceCooldown: number;\n    mineCooldown: number;\n  }): this {\n    this.position = { x, y };\n    this.life = myLife;\n    this.torpedoCooldown = torpedoCooldown;\n    this.sonarCooldown = sonarCooldown;\n    this.silenceCooldown = silenceCooldown;\n    this.mineCooldown = mineCooldown;\n\n    return this;\n  }\n}\n\nexport default MySubmarine;\n","import PhantomSubmarineTracker from '../phantom-submarine-tracker';\nimport MySubmarine from '../my-submarine';\nimport { ECommand } from '../command-interpreter';\n\nexport interface IWeightedAction {\n  type: ECommand;\n  utility: number;\n  parameters?: any;\n}\n\nclass BaseAction {\n  protected mySubmarine: MySubmarine;\n  protected phantomSubmarineTracker: PhantomSubmarineTracker;\n\n  constructor({\n    mySubmarine,\n    phantomSubmarineTracker,\n  }: {\n    mySubmarine: MySubmarine;\n    phantomSubmarineTracker: PhantomSubmarineTracker;\n  }) {\n    this.mySubmarine = mySubmarine;\n    this.phantomSubmarineTracker = phantomSubmarineTracker;\n  }\n}\n\nexport default BaseAction;\n","import graph, { ICoordinates } from '../graph';\nimport BaseAction, { IWeightedAction } from './base-action';\nimport { CONST_TORPEDO_RANGE, CONST_TORPEDO_DAMAGE } from '../constants';\nimport { ECommand } from '../command-interpreter';\n\nconst expectedUtilityForDamage = ({\n  damageToMe,\n  damageToMyOpponent,\n  myHealth,\n  opponentHealth,\n  maxDamage,\n}: {\n  damageToMe: number;\n  damageToMyOpponent: number;\n  myHealth: number;\n  opponentHealth: number;\n  maxDamage: number;\n}): number => {\n  if (opponentHealth <= damageToMyOpponent && damageToMe < myHealth) {\n    return 1;\n  }\n\n  if (0 < damageToMe) {\n    return 0;\n  }\n\n  if (0 < damageToMyOpponent) {\n    return maxDamage === damageToMyOpponent ? 1 : 0.8;\n  }\n\n  return 0;\n};\n\nconst calculateDamage = ({\n  direct,\n  collateral,\n}: {\n  direct: boolean;\n  collateral: boolean;\n}): number => {\n  if (direct) {\n    return CONST_TORPEDO_DAMAGE;\n  }\n\n  if (collateral) {\n    return CONST_TORPEDO_DAMAGE / 2;\n  }\n\n  return 0;\n};\n\nexport class TorpedoAction extends BaseAction {\n  calculateUtility(): IWeightedAction {\n    if (this.mySubmarine.isTorpedoReady() === false) {\n      return {\n        type: ECommand.TORPEDO,\n        utility: 0,\n      };\n    }\n\n    const myHealth = this.mySubmarine.getLife();\n    const myLocation = this.mySubmarine.getPosition();\n    const gameMap = this.mySubmarine.getGameMap();\n\n    const opponentHealth = this.phantomSubmarineTracker.getOpponentLife();\n    const possibleOpponentLocationsMap = this.phantomSubmarineTracker.getPossibleLocationsMap();\n    const numOfPossibleLocationsForOpponent = Object.keys(possibleOpponentLocationsMap).length;\n\n    const possibleLocationsToFireAt = gameMap.getReachableCoordinatesAtDistance({\n      coordinates: myLocation,\n      maxDistance: CONST_TORPEDO_RANGE,\n    });\n\n    let bestUtility = -1;\n    let coordinatesToFireAt: ICoordinates = myLocation;\n\n    possibleLocationsToFireAt.forEach(possibleLocationToFireAt => {\n      const utilities: number[] = [];\n      const possibleLocationsToCatchDamage = graph.getNeighbouringCellsIncludingDiagonal(\n        possibleLocationToFireAt\n      );\n      const doesItHitMe = graph.isCoordinatesInCoordinatesList(myLocation, [\n        possibleLocationToFireAt,\n      ]);\n      const doITakeCollateral = graph.isCoordinatesInCoordinatesList(\n        myLocation,\n        possibleLocationsToCatchDamage\n      );\n\n      const damageToMe = calculateDamage({ direct: doesItHitMe, collateral: doITakeCollateral });\n      const locationHitAtAsKey = graph.transformCoordinatesToKey(possibleLocationToFireAt);\n\n      if (possibleOpponentLocationsMap[locationHitAtAsKey] === true) {\n        utilities.push(\n          expectedUtilityForDamage({\n            damageToMe,\n            damageToMyOpponent: calculateDamage({ direct: true, collateral: false }),\n            myHealth,\n            opponentHealth,\n            maxDamage: CONST_TORPEDO_DAMAGE,\n          })\n        );\n      } else {\n        utilities.push(0);\n      }\n\n      possibleLocationsToCatchDamage.forEach(possibleLocationToCatchDamage => {\n        const locationCaughtDamageAsKey = graph.transformCoordinatesToKey(\n          possibleLocationToCatchDamage\n        );\n        if (possibleOpponentLocationsMap[locationCaughtDamageAsKey] === true) {\n          utilities.push(\n            expectedUtilityForDamage({\n              damageToMe,\n              damageToMyOpponent: calculateDamage({ direct: false, collateral: true }),\n              myHealth,\n              opponentHealth,\n              maxDamage: CONST_TORPEDO_DAMAGE,\n            })\n          );\n        } else {\n          utilities.push(0);\n        }\n      });\n\n      const utility =\n        utilities.reduce((a, b) => {\n          return a + b;\n        }, 0) / numOfPossibleLocationsForOpponent;\n\n      if (bestUtility < utility) {\n        bestUtility = utility;\n        coordinatesToFireAt = possibleLocationToFireAt;\n      }\n    });\n\n    return {\n      type: ECommand.TORPEDO,\n      utility: bestUtility,\n      parameters: { coordinates: coordinatesToFireAt },\n    };\n  }\n}\n\nexport default TorpedoAction;\n","import graph from '../graph';\nimport BaseAction, { IWeightedAction } from './base-action';\nimport { ECommand } from '../command-interpreter';\n\nexport class SurfaceAction extends BaseAction {\n  calculateUtility(): IWeightedAction {\n    const myLocation = this.mySubmarine.getPosition();\n    const gameMap = this.mySubmarine.getGameMap();\n    const possibleLocationsToMoveTo = graph.getNeighbouringCells(myLocation).filter(coordinates => {\n      return gameMap.isCellWalkable(coordinates);\n    });\n\n    const utility = possibleLocationsToMoveTo.length === 0 ? 1 : 0;\n\n    return {\n      type: ECommand.SURFACE,\n      utility,\n    };\n  }\n}\n\nexport default SurfaceAction;\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  if (typeof module !== \"undefined\" && module !== null ? module.exports : void 0) {\n    module.exports = Heap;\n  } else {\n    window.Heap = Heap;\n  }\n\n}).call(this);\n","module.exports = require('./lib/heap');\n","/**\r\n * A node in grid. \r\n * This class holds some basic information about a node and custom \r\n * attributes may be added, depending on the algorithms' needs.\r\n * @constructor\r\n * @param {number} x - The x coordinate of the node on the grid.\r\n * @param {number} y - The y coordinate of the node on the grid.\r\n * @param {boolean} [walkable] - Whether this node is walkable.\r\n */\r\nfunction Node(x, y, walkable) {\r\n    /**\r\n     * The x coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.x = x;\r\n    /**\r\n     * The y coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.y = y;\r\n    /**\r\n     * Whether this node can be walked through.\r\n     * @type boolean\r\n     */\r\n    this.walkable = (walkable === undefined ? true : walkable);\r\n}\r\n\r\nmodule.exports = Node;\r\n","var DiagonalMovement = {\r\n    Always: 1,\r\n    Never: 2,\r\n    IfAtMostOneObstacle: 3,\r\n    OnlyWhenNoObstacles: 4\r\n};\r\n\r\nmodule.exports = DiagonalMovement;","var Node = require('./Node');\r\nvar DiagonalMovement = require('./DiagonalMovement');\r\n\r\n/**\r\n * The Grid class, which serves as the encapsulation of the layout of the nodes.\r\n * @constructor\r\n * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix\r\n * @param {number} height Number of rows of the grid.\r\n * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix\r\n *     representing the walkable status of the nodes(0 or false for walkable).\r\n *     If the matrix is not supplied, all the nodes will be walkable.  */\r\nfunction Grid(width_or_matrix, height, matrix) {\r\n    var width;\r\n\r\n    if (typeof width_or_matrix !== 'object') {\r\n        width = width_or_matrix;\r\n    } else {\r\n        height = width_or_matrix.length;\r\n        width = width_or_matrix[0].length;\r\n        matrix = width_or_matrix;\r\n    }\r\n\r\n    /**\r\n     * The number of columns of the grid.\r\n     * @type number\r\n     */\r\n    this.width = width;\r\n    /**\r\n     * The number of rows of the grid.\r\n     * @type number\r\n     */\r\n    this.height = height;\r\n\r\n    /**\r\n     * A 2D array of nodes.\r\n     */\r\n    this.nodes = this._buildNodes(width, height, matrix);\r\n}\r\n\r\n/**\r\n * Build and return the nodes.\r\n * @private\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing\r\n *     the walkable status of the nodes.\r\n * @see Grid\r\n */\r\nGrid.prototype._buildNodes = function(width, height, matrix) {\r\n    var i, j,\r\n        nodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        nodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            nodes[i][j] = new Node(j, i);\r\n        }\r\n    }\r\n\r\n\r\n    if (matrix === undefined) {\r\n        return nodes;\r\n    }\r\n\r\n    if (matrix.length !== height || matrix[0].length !== width) {\r\n        throw new Error('Matrix size does not fit');\r\n    }\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        for (j = 0; j < width; ++j) {\r\n            if (matrix[i][j]) {\r\n                // 0, false, null will be walkable\r\n                // while others will be un-walkable\r\n                nodes[i][j].walkable = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n};\r\n\r\n\r\nGrid.prototype.getNodeAt = function(x, y) {\r\n    return this.nodes[y][x];\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the node at the given position is walkable.\r\n * (Also returns false if the position is outside the grid.)\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @return {boolean} - The walkability of the node.\r\n */\r\nGrid.prototype.isWalkableAt = function(x, y) {\r\n    return this.isInside(x, y) && this.nodes[y][x].walkable;\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the position is inside the grid.\r\n * XXX: `grid.isInside(x, y)` is wierd to read.\r\n * It should be `(x, y) is inside grid`, but I failed to find a better\r\n * name for this method.\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nGrid.prototype.isInside = function(x, y) {\r\n    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);\r\n};\r\n\r\n\r\n/**\r\n * Set whether the node on the given position is walkable.\r\n * NOTE: throws exception if the coordinate is not inside the grid.\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @param {boolean} walkable - Whether the position is walkable.\r\n */\r\nGrid.prototype.setWalkableAt = function(x, y, walkable) {\r\n    this.nodes[y][x].walkable = walkable;\r\n};\r\n\r\n\r\n/**\r\n * Get the neighbors of the given node.\r\n *\r\n *     offsets      diagonalOffsets:\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 0 |   |    | 0 |   | 1 |\r\n *  +---+---+---+    +---+---+---+\r\n *  | 3 |   | 1 |    |   |   |   |\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 2 |   |    | 3 |   | 2 |\r\n *  +---+---+---+    +---+---+---+\r\n *\r\n *  When allowDiagonal is true, if offsets[i] is valid, then\r\n *  diagonalOffsets[i] and\r\n *  diagonalOffsets[(i + 1) % 4] is valid.\r\n * @param {Node} node\r\n * @param {DiagonalMovement} diagonalMovement\r\n */\r\nGrid.prototype.getNeighbors = function(node, diagonalMovement) {\r\n    var x = node.x,\r\n        y = node.y,\r\n        neighbors = [],\r\n        s0 = false, d0 = false,\r\n        s1 = false, d1 = false,\r\n        s2 = false, d2 = false,\r\n        s3 = false, d3 = false,\r\n        nodes = this.nodes;\r\n\r\n    // \r\n    if (this.isWalkableAt(x, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x]);\r\n        s0 = true;\r\n    }\r\n    // \r\n    if (this.isWalkableAt(x + 1, y)) {\r\n        neighbors.push(nodes[y][x + 1]);\r\n        s1 = true;\r\n    }\r\n    // \r\n    if (this.isWalkableAt(x, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x]);\r\n        s2 = true;\r\n    }\r\n    // \r\n    if (this.isWalkableAt(x - 1, y)) {\r\n        neighbors.push(nodes[y][x - 1]);\r\n        s3 = true;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.Never) {\r\n        return neighbors;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        d0 = s3 && s0;\r\n        d1 = s0 && s1;\r\n        d2 = s1 && s2;\r\n        d3 = s2 && s3;\r\n    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {\r\n        d0 = s3 || s0;\r\n        d1 = s0 || s1;\r\n        d2 = s1 || s2;\r\n        d3 = s2 || s3;\r\n    } else if (diagonalMovement === DiagonalMovement.Always) {\r\n        d0 = true;\r\n        d1 = true;\r\n        d2 = true;\r\n        d3 = true;\r\n    } else {\r\n        throw new Error('Incorrect value of diagonalMovement');\r\n    }\r\n\r\n    // \r\n    if (d0 && this.isWalkableAt(x - 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x - 1]);\r\n    }\r\n    // \r\n    if (d1 && this.isWalkableAt(x + 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x + 1]);\r\n    }\r\n    // \r\n    if (d2 && this.isWalkableAt(x + 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x + 1]);\r\n    }\r\n    // \r\n    if (d3 && this.isWalkableAt(x - 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x - 1]);\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\n\r\n/**\r\n * Get a clone of this grid.\r\n * @return {Grid} Cloned grid.\r\n */\r\nGrid.prototype.clone = function() {\r\n    var i, j,\r\n\r\n        width = this.width,\r\n        height = this.height,\r\n        thisNodes = this.nodes,\r\n\r\n        newGrid = new Grid(width, height),\r\n        newNodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        newNodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);\r\n        }\r\n    }\r\n\r\n    newGrid.nodes = newNodes;\r\n\r\n    return newGrid;\r\n};\r\n\r\nmodule.exports = Grid;\r\n","/**\r\n * Backtrace according to the parent records and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node} node End node\r\n * @return {Array<Array<number>>} the path\r\n */\r\nfunction backtrace(node) {\r\n    var path = [[node.x, node.y]];\r\n    while (node.parent) {\r\n        node = node.parent;\r\n        path.push([node.x, node.y]);\r\n    }\r\n    return path.reverse();\r\n}\r\nexports.backtrace = backtrace;\r\n\r\n/**\r\n * Backtrace from start and end node, and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node}\r\n * @param {Node}\r\n */\r\nfunction biBacktrace(nodeA, nodeB) {\r\n    var pathA = backtrace(nodeA),\r\n        pathB = backtrace(nodeB);\r\n    return pathA.concat(pathB.reverse());\r\n}\r\nexports.biBacktrace = biBacktrace;\r\n\r\n/**\r\n * Compute the length of the path.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {number} The length of the path\r\n */\r\nfunction pathLength(path) {\r\n    var i, sum = 0, a, b, dx, dy;\r\n    for (i = 1; i < path.length; ++i) {\r\n        a = path[i - 1];\r\n        b = path[i];\r\n        dx = a[0] - b[0];\r\n        dy = a[1] - b[1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    return sum;\r\n}\r\nexports.pathLength = pathLength;\r\n\r\n\r\n/**\r\n * Given the start and end coordinates, return all the coordinates lying\r\n * on the line formed by these coordinates, based on Bresenham's algorithm.\r\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\r\n * @param {number} x0 Start x coordinate\r\n * @param {number} y0 Start y coordinate\r\n * @param {number} x1 End x coordinate\r\n * @param {number} y1 End y coordinate\r\n * @return {Array<Array<number>>} The coordinates on the line\r\n */\r\nfunction interpolate(x0, y0, x1, y1) {\r\n    var abs = Math.abs,\r\n        line = [],\r\n        sx, sy, dx, dy, err, e2;\r\n\r\n    dx = abs(x1 - x0);\r\n    dy = abs(y1 - y0);\r\n\r\n    sx = (x0 < x1) ? 1 : -1;\r\n    sy = (y0 < y1) ? 1 : -1;\r\n\r\n    err = dx - dy;\r\n\r\n    while (true) {\r\n        line.push([x0, y0]);\r\n\r\n        if (x0 === x1 && y0 === y1) {\r\n            break;\r\n        }\r\n        \r\n        e2 = 2 * err;\r\n        if (e2 > -dy) {\r\n            err = err - dy;\r\n            x0 = x0 + sx;\r\n        }\r\n        if (e2 < dx) {\r\n            err = err + dx;\r\n            y0 = y0 + sy;\r\n        }\r\n    }\r\n\r\n    return line;\r\n}\r\nexports.interpolate = interpolate;\r\n\r\n\r\n/**\r\n * Given a compressed path, return a new path that has all the segments\r\n * in it interpolated.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} expanded path\r\n */\r\nfunction expandPath(path) {\r\n    var expanded = [],\r\n        len = path.length,\r\n        coord0, coord1,\r\n        interpolated,\r\n        interpolatedLen,\r\n        i, j;\r\n\r\n    if (len < 2) {\r\n        return expanded;\r\n    }\r\n\r\n    for (i = 0; i < len - 1; ++i) {\r\n        coord0 = path[i];\r\n        coord1 = path[i + 1];\r\n\r\n        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\r\n        interpolatedLen = interpolated.length;\r\n        for (j = 0; j < interpolatedLen - 1; ++j) {\r\n            expanded.push(interpolated[j]);\r\n        }\r\n    }\r\n    expanded.push(path[len - 1]);\r\n\r\n    return expanded;\r\n}\r\nexports.expandPath = expandPath;\r\n\r\n\r\n/**\r\n * Smoothen the give path.\r\n * The original path will not be modified; a new path will be returned.\r\n * @param {PF.Grid} grid\r\n * @param {Array<Array<number>>} path The path\r\n */\r\nfunction smoothenPath(grid, path) {\r\n    var len = path.length,\r\n        x0 = path[0][0],        // path start x\r\n        y0 = path[0][1],        // path start y\r\n        x1 = path[len - 1][0],  // path end x\r\n        y1 = path[len - 1][1],  // path end y\r\n        sx, sy,                 // current start coordinate\r\n        ex, ey,                 // current end coordinate\r\n        newPath,\r\n        i, j, coord, line, testCoord, blocked;\r\n\r\n    sx = x0;\r\n    sy = y0;\r\n    newPath = [[sx, sy]];\r\n\r\n    for (i = 2; i < len; ++i) {\r\n        coord = path[i];\r\n        ex = coord[0];\r\n        ey = coord[1];\r\n        line = interpolate(sx, sy, ex, ey);\r\n\r\n        blocked = false;\r\n        for (j = 1; j < line.length; ++j) {\r\n            testCoord = line[j];\r\n\r\n            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\r\n                blocked = true;\r\n                break;\r\n            }\r\n        }\r\n        if (blocked) {\r\n            lastValidCoord = path[i - 1];\r\n            newPath.push(lastValidCoord);\r\n            sx = lastValidCoord[0];\r\n            sy = lastValidCoord[1];\r\n        }\r\n    }\r\n    newPath.push([x1, y1]);\r\n\r\n    return newPath;\r\n}\r\nexports.smoothenPath = smoothenPath;\r\n\r\n\r\n/**\r\n * Compress a path, remove redundant nodes without altering the shape\r\n * The original path is not modified\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} The compressed path\r\n */\r\nfunction compressPath(path) {\r\n\r\n    // nothing to compress\r\n    if(path.length < 3) {\r\n        return path;\r\n    }\r\n\r\n    var compressed = [],\r\n        sx = path[0][0], // start x\r\n        sy = path[0][1], // start y\r\n        px = path[1][0], // second point x\r\n        py = path[1][1], // second point y\r\n        dx = px - sx, // direction between the two points\r\n        dy = py - sy, // direction between the two points\r\n        lx, ly,\r\n        ldx, ldy,\r\n        sq, i;\r\n\r\n    // normalize the direction\r\n    sq = Math.sqrt(dx*dx + dy*dy);\r\n    dx /= sq;\r\n    dy /= sq;\r\n\r\n    // start the new path\r\n    compressed.push([sx,sy]);\r\n\r\n    for(i = 2; i < path.length; i++) {\r\n\r\n        // store the last point\r\n        lx = px;\r\n        ly = py;\r\n\r\n        // store the last direction\r\n        ldx = dx;\r\n        ldy = dy;\r\n\r\n        // next point\r\n        px = path[i][0];\r\n        py = path[i][1];\r\n\r\n        // next direction\r\n        dx = px - lx;\r\n        dy = py - ly;\r\n\r\n        // normalize\r\n        sq = Math.sqrt(dx*dx + dy*dy);\r\n        dx /= sq;\r\n        dy /= sq;\r\n\r\n        // if the direction has changed, store the point\r\n        if ( dx !== ldx || dy !== ldy ) {\r\n            compressed.push([lx,ly]);\r\n        }\r\n    }\r\n\r\n    // store the last point\r\n    compressed.push([px,py]);\r\n\r\n    return compressed;\r\n}\r\nexports.compressPath = compressPath;\r\n","/**\r\n * @namespace PF.Heuristic\r\n * @description A collection of heuristic functions.\r\n */\r\nmodule.exports = {\r\n\r\n  /**\r\n   * Manhattan distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} dx + dy\r\n   */\r\n  manhattan: function(dx, dy) {\r\n      return dx + dy;\r\n  },\r\n\r\n  /**\r\n   * Euclidean distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy)\r\n   */\r\n  euclidean: function(dx, dy) {\r\n      return Math.sqrt(dx * dx + dy * dy);\r\n  },\r\n\r\n  /**\r\n   * Octile distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy) for grids\r\n   */\r\n  octile: function(dx, dy) {\r\n      var F = Math.SQRT2 - 1;\r\n      return (dx < dy) ? F * dx + dy : F * dy + dx;\r\n  },\r\n\r\n  /**\r\n   * Chebyshev distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} max(dx, dy)\r\n   */\r\n  chebyshev: function(dx, dy) {\r\n      return Math.max(dx, dy);\r\n  }\r\n\r\n};\r\n","var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder. Based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching \r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction AStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    //admissible. It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        // if reached the end position, construct the path and return it\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    openList.push(neighbor);\r\n                    neighbor.opened = true;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    openList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = AStarFinder;\r\n","var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Best-First-Search path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BestFirstFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBestFirstFinder.prototype = new AStarFinder();\r\nBestFirstFinder.prototype.constructor = BestFirstFinder;\r\n\r\nmodule.exports = BestFirstFinder;\r\n","var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = [],\r\n        diagonalMovement = this.diagonalMovement,\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        neighbors, neighbor, node, i, l;\r\n\r\n    // push the start pos into the queue\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the queue is not empty\r\n    while (openList.length) {\r\n        // take the front node from the queue\r\n        node = openList.shift();\r\n        node.closed = true;\r\n\r\n        // reached the end position\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            // skip this neighbor if it has been inspected before\r\n            if (neighbor.closed || neighbor.opened) {\r\n                continue;\r\n            }\r\n\r\n            openList.push(neighbor);\r\n            neighbor.opened = true;\r\n            neighbor.parent = node;\r\n        }\r\n    }\r\n    \r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BreadthFirstFinder;\r\n","var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Dijkstra path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction DijkstraFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nDijkstraFinder.prototype = new AStarFinder();\r\nDijkstraFinder.prototype.constructor = DijkstraFinder;\r\n\r\nmodule.exports = DijkstraFinder;\r\n","var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder.\r\n * based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction BiAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\r\n    //It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var cmp = function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        },\r\n        startOpenList = new Heap(cmp),\r\n        endOpenList = new Heap(cmp),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng,\r\n        BY_START = 1, BY_END = 2;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    // and push it into the start open list\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n    startOpenList.push(startNode);\r\n    startNode.opened = BY_START;\r\n\r\n    // set the `g` and `f` value of the end node to be 0\r\n    // and push it into the open open list\r\n    endNode.g = 0;\r\n    endNode.f = 0;\r\n    endOpenList.push(endNode);\r\n    endNode.opened = BY_END;\r\n\r\n    // while both the open lists are not empty\r\n    while (!startOpenList.empty() && !endOpenList.empty()) {\r\n\r\n        // pop the position of start node which has the minimum `f` value.\r\n        node = startOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_END) {\r\n                return Util.biBacktrace(node, neighbor);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    startOpenList.push(neighbor);\r\n                    neighbor.opened = BY_START;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    startOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n\r\n\r\n        // pop the position of end node which has the minimum `f` value.\r\n        node = endOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_START) {\r\n                return Util.biBacktrace(neighbor, node);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - startX), abs(y - startY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    endOpenList.push(neighbor);\r\n                    neighbor.opened = BY_END;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    endOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiAStarFinder;\r\n","var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-direcitional Best-First-Search path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BiBestFirstFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBiBestFirstFinder.prototype = new BiAStarFinder();\r\nBiBestFirstFinder.prototype.constructor = BiBestFirstFinder;\r\n\r\nmodule.exports = BiBestFirstFinder;\r\n","var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Bi-directional Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiBreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        startOpenList = [], endOpenList = [],\r\n        neighbors, neighbor, node,\r\n        diagonalMovement = this.diagonalMovement,\r\n        BY_START = 0, BY_END = 1,\r\n        i, l;\r\n\r\n    // push the start and end nodes into the queues\r\n    startOpenList.push(startNode);\r\n    startNode.opened = true;\r\n    startNode.by = BY_START;\r\n\r\n    endOpenList.push(endNode);\r\n    endNode.opened = true;\r\n    endNode.by = BY_END;\r\n\r\n    // while both the queues are not empty\r\n    while (startOpenList.length && endOpenList.length) {\r\n\r\n        // expand start open list\r\n\r\n        node = startOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                // if this node has been inspected by the reversed search,\r\n                // then a path is found.\r\n                if (neighbor.by === BY_END) {\r\n                    return Util.biBacktrace(node, neighbor);\r\n                }\r\n                continue;\r\n            }\r\n            startOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_START;\r\n        }\r\n\r\n        // expand end open list\r\n\r\n        node = endOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                if (neighbor.by === BY_START) {\r\n                    return Util.biBacktrace(neighbor, node);\r\n                }\r\n                continue;\r\n            }\r\n            endOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_END;\r\n        }\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiBreadthFirstFinder;\r\n","var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-directional Dijkstra path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiDijkstraFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nBiDijkstraFinder.prototype = new BiAStarFinder();\r\nBiDijkstraFinder.prototype.constructor = BiDijkstraFinder;\r\n\r\nmodule.exports = BiDijkstraFinder;\r\n","var Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar Node       = require('../core/Node');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Iterative Deeping A Star (IDA*) path-finder.\r\n *\r\n * Recursion based on:\r\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\r\n *\r\n * Path retracing based on:\r\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\r\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\r\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\r\n *\r\n * @author Gerard Meier (www.gerardmeier.com)\r\n *\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n * @param {boolean} opt.trackRecursion Whether to track recursion for\r\n *     statistical purposes.\r\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\r\n */\r\nfunction IDAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.trackRecursion = opt.trackRecursion || false;\r\n    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    // admissible, it should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path. When an empty array is returned, either\r\n * no path is possible, or the maximum execution time is reached.\r\n *\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nIDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    // Used for statistics:\r\n    var nodesVisited = 0;\r\n\r\n    // Execution time limitation:\r\n    var startTime = new Date().getTime();\r\n\r\n    // Heuristic helper:\r\n    var h = function(a, b) {\r\n        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\r\n    }.bind(this);\r\n\r\n    // Step cost from a to b:\r\n    var cost = function(a, b) {\r\n        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;\r\n    };\r\n\r\n    /**\r\n     * IDA* search implementation.\r\n     *\r\n     * @param {Node} The node currently expanding from.\r\n     * @param {number} Cost to reach the given node.\r\n     * @param {number} Maximum search depth (cut-off value).\r\n     * @param {Array<Array<number>>} The found route.\r\n     * @param {number} Recursion depth.\r\n     *\r\n     * @return {Object} either a number with the new optimal cut-off depth,\r\n     * or a valid node instance, in which case a path was found.\r\n     */\r\n    var search = function(node, g, cutoff, route, depth) {\r\n        nodesVisited++;\r\n\r\n        // Enforce timelimit:\r\n        if (this.timeLimit > 0 &&\r\n            new Date().getTime() - startTime > this.timeLimit * 1000) {\r\n            // Enforced as \"path-not-found\".\r\n            return Infinity;\r\n        }\r\n\r\n        var f = g + h(node, end) * this.weight;\r\n\r\n        // We've searched too deep for this iteration.\r\n        if (f > cutoff) {\r\n            return f;\r\n        }\r\n\r\n        if (node == end) {\r\n            route[depth] = [node.x, node.y];\r\n            return node;\r\n        }\r\n\r\n        var min, t, k, neighbour;\r\n\r\n        var neighbours = grid.getNeighbors(node, this.diagonalMovement);\r\n\r\n        // Sort the neighbours, gives nicer paths. But, this deviates\r\n        // from the original algorithm - so I left it out.\r\n        //neighbours.sort(function(a, b){\r\n        //    return h(a, end) - h(b, end);\r\n        //});\r\n\r\n        \r\n        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment\r\n        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\r\n        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment\r\n            if (this.trackRecursion) {\r\n                // Retain a copy for visualisation. Due to recursion, this\r\n                // node may be part of other paths too.\r\n                neighbour.retainCount = neighbour.retainCount + 1 || 1;\r\n\r\n                if(neighbour.tested !== true) {\r\n                    neighbour.tested = true;\r\n                }\r\n            }\r\n\r\n            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\r\n\r\n            if (t instanceof Node) {\r\n                route[depth] = [node.x, node.y];\r\n\r\n                // For a typical A* linked list, this would work:\r\n                // neighbour.parent = node;\r\n                return t;\r\n            }\r\n\r\n            // Decrement count, then determine whether it's actually closed.\r\n            if (this.trackRecursion && (--neighbour.retainCount) === 0) {\r\n                neighbour.tested = false;\r\n            }\r\n\r\n            if (t < min) {\r\n                min = t;\r\n            }\r\n        }\r\n\r\n        return min;\r\n\r\n    }.bind(this);\r\n\r\n    // Node instance lookups:\r\n    var start = grid.getNodeAt(startX, startY);\r\n    var end   = grid.getNodeAt(endX, endY);\r\n\r\n    // Initial search depth, given the typical heuristic contraints,\r\n    // there should be no cheaper route possible.\r\n    var cutOff = h(start, end);\r\n\r\n    var j, route, t;\r\n\r\n    // With an overflow protection.\r\n    for (j = 0; true; ++j) {\r\n\r\n        route = [];\r\n\r\n        // Search till cut-off depth:\r\n        t = search(start, 0, cutOff, route, 0);\r\n\r\n        // Route not possible, or not found in time limit.\r\n        if (t === Infinity) {\r\n            return [];\r\n        }\r\n\r\n        // If t is a node, it's also the end node. Route is now\r\n        // populated with a valid path to the end node.\r\n        if (t instanceof Node) {\r\n            return route;\r\n        }\r\n\r\n        // Try again, this time with a deeper cut-off. The t score\r\n        // is the closest we got to the end node.\r\n        cutOff = t;\r\n    }\r\n\r\n    // This _should_ never to be reached.\r\n    return [];\r\n};\r\n\r\nmodule.exports = IDAStarFinder;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Base class for the Jump Point Search algorithm\r\n * @param {object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction JumpPointFinderBase(opt) {\r\n    opt = opt || {};\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.trackJumpRecursion = opt.trackJumpRecursion || false;\r\n}\r\n\r\n/**\r\n * Find and return the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nJumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = this.openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = this.startNode = grid.getNodeAt(startX, startY),\r\n        endNode = this.endNode = grid.getNodeAt(endX, endY), node;\r\n\r\n    this.grid = grid;\r\n\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        if (node === endNode) {\r\n            return Util.expandPath(Util.backtrace(endNode));\r\n        }\r\n\r\n        this._identifySuccessors(node);\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\n/**\r\n * Identify successors for the given node. Runs a jump point search in the\r\n * direction of each available neighbor, adding any points found to the open\r\n * list.\r\n * @protected\r\n */\r\nJumpPointFinderBase.prototype._identifySuccessors = function(node) {\r\n    var grid = this.grid,\r\n        heuristic = this.heuristic,\r\n        openList = this.openList,\r\n        endX = this.endNode.x,\r\n        endY = this.endNode.y,\r\n        neighbors, neighbor,\r\n        jumpPoint, i, l,\r\n        x = node.x, y = node.y,\r\n        jx, jy, dx, dy, d, ng, jumpNode,\r\n        abs = Math.abs, max = Math.max;\r\n\r\n    neighbors = this._findNeighbors(node);\r\n    for(i = 0, l = neighbors.length; i < l; ++i) {\r\n        neighbor = neighbors[i];\r\n        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\r\n        if (jumpPoint) {\r\n\r\n            jx = jumpPoint[0];\r\n            jy = jumpPoint[1];\r\n            jumpNode = grid.getNodeAt(jx, jy);\r\n\r\n            if (jumpNode.closed) {\r\n                continue;\r\n            }\r\n\r\n            // include distance, as parent may not be immediately adjacent:\r\n            d = Heuristic.octile(abs(jx - x), abs(jy - y));\r\n            ng = node.g + d; // next `g` value\r\n\r\n            if (!jumpNode.opened || ng < jumpNode.g) {\r\n                jumpNode.g = ng;\r\n                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\r\n                jumpNode.f = jumpNode.g + jumpNode.h;\r\n                jumpNode.parent = node;\r\n\r\n                if (!jumpNode.opened) {\r\n                    openList.push(jumpNode);\r\n                    jumpNode.opened = true;\r\n                } else {\r\n                    openList.updateItem(jumpNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = JumpPointFinderBase;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm allowing only horizontal\r\n * or vertical movements.\r\n */\r\nfunction JPFNeverMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    if (dx !== 0) {\r\n        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else if (dy !== 0) {\r\n        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        //When moving vertically, must check for horizontal jump points\r\n        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"Only horizontal and vertical movements are allowed\");\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        if (dx !== 0) {\r\n            if (grid.isWalkableAt(x, y - 1)) {\r\n                neighbors.push([x, y - 1]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + 1)) {\r\n                neighbors.push([x, y + 1]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if (grid.isWalkableAt(x - 1, y)) {\r\n                neighbors.push([x - 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + 1, y)) {\r\n                neighbors.push([x + 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFNeverMoveDiagonally;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which always moves\r\n * diagonally irrespective of the number of obstacles.\r\n */\r\nfunction JPFAlwaysMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y + dy)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x + 1, y)) {\r\n                    neighbors.push([x + 1, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x - 1, y)) {\r\n                    neighbors.push([x - 1, y + dy]);\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y + 1)) {\r\n                    neighbors.push([x + dx, y + 1]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y - 1)) {\r\n                    neighbors.push([x + dx, y - 1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFAlwaysMoveDiagonally;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there are no obstacles.\r\n */\r\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            // return [x, y];\r\n        // }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if (dx !== 0) {\r\n            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n                return [x, y];\r\n            }\r\n            // When moving vertically, must check for horizontal jump points\r\n            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n                // return [x, y];\r\n            // }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            var isNextWalkable;\r\n            if (dx !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x + dx, y);\r\n                var isTopWalkable = grid.isWalkableAt(x, y + 1);\r\n                var isBottomWalkable = grid.isWalkableAt(x, y - 1);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (isTopWalkable) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (isBottomWalkable) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n                if (isTopWalkable) {\r\n                    neighbors.push([x, y + 1]);\r\n                }\r\n                if (isBottomWalkable) {\r\n                    neighbors.push([x, y - 1]);\r\n                }\r\n            }\r\n            else if (dy !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x, y + dy);\r\n                var isRightWalkable = grid.isWalkableAt(x + 1, y);\r\n                var isLeftWalkable = grid.isWalkableAt(x - 1, y);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (isRightWalkable) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (isLeftWalkable) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n                if (isRightWalkable) {\r\n                    neighbors.push([x + 1, y]);\r\n                }\r\n                if (isLeftWalkable) {\r\n                    neighbors.push([x - 1, y]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there is at most one obstacle.\r\n */\r\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (!grid.isWalkableAt(x + 1, y)) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x - 1, y)) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (!grid.isWalkableAt(x, y + 1)) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x, y - 1)) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n","/**\r\n * @author aniero / https://github.com/aniero\r\n */\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\nvar JPFNeverMoveDiagonally = require('./JPFNeverMoveDiagonally');\r\nvar JPFAlwaysMoveDiagonally = require('./JPFAlwaysMoveDiagonally');\r\nvar JPFMoveDiagonallyIfNoObstacles = require('./JPFMoveDiagonallyIfNoObstacles');\r\nvar JPFMoveDiagonallyIfAtMostOneObstacle = require('./JPFMoveDiagonallyIfAtMostOneObstacle');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm\r\n * @param {Object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\r\n *      movement will be allowed.\r\n */\r\nfunction JumpPointFinder(opt) {\r\n    opt = opt || {};\r\n    if (opt.diagonalMovement === DiagonalMovement.Never) {\r\n        return new JPFNeverMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.Always) {\r\n        return new JPFAlwaysMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        return new JPFMoveDiagonallyIfNoObstacles(opt);\r\n    } else {\r\n        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\r\n    }\r\n}\r\n\r\nmodule.exports = JumpPointFinder;\r\n","module.exports = {\r\n    'Heap'                      : require('heap'),\r\n    'Node'                      : require('./core/Node'),\r\n    'Grid'                      : require('./core/Grid'),\r\n    'Util'                      : require('./core/Util'),\r\n    'DiagonalMovement'          : require('./core/DiagonalMovement'),\r\n    'Heuristic'                 : require('./core/Heuristic'),\r\n    'AStarFinder'               : require('./finders/AStarFinder'),\r\n    'BestFirstFinder'           : require('./finders/BestFirstFinder'),\r\n    'BreadthFirstFinder'        : require('./finders/BreadthFirstFinder'),\r\n    'DijkstraFinder'            : require('./finders/DijkstraFinder'),\r\n    'BiAStarFinder'             : require('./finders/BiAStarFinder'),\r\n    'BiBestFirstFinder'         : require('./finders/BiBestFirstFinder'),\r\n    'BiBreadthFirstFinder'      : require('./finders/BiBreadthFirstFinder'),\r\n    'BiDijkstraFinder'          : require('./finders/BiDijkstraFinder'),\r\n    'IDAStarFinder'             : require('./finders/IDAStarFinder'),\r\n    'JumpPointFinder'           : require('./finders/JumpPointFinder'),\r\n};\r\n","module.exports = require('./src/PathFinding');\r\n","import graph, { ICoordinates } from '../graph';\nimport BaseAction, { IWeightedAction } from './base-action';\nimport { ECommand } from '../command-interpreter';\nimport * as PF from 'pathfinding';\n\nconst finder: PF.AStarFinder = new PF.AStarFinder();\n\nexport class MoveAction extends BaseAction {\n  calculateUtility(): IWeightedAction {\n    const myLocation = this.mySubmarine.getPosition();\n    const gameMap = this.mySubmarine.getGameMap();\n    const possibleLocationsToMoveTo = graph.getNeighbouringCells(myLocation).filter(coordinates => {\n      return gameMap.isCellWalkable(coordinates);\n    });\n\n    if (possibleLocationsToMoveTo.length === 0) {\n      return {\n        type: ECommand.MOVE,\n        utility: 0,\n      };\n    }\n\n    const possibleOpponentLocationsMap = this.phantomSubmarineTracker.getPossibleLocationsMap();\n    const coordinatesAsKeys = Object.keys(possibleOpponentLocationsMap);\n\n    const possibleOpponentLocation: ICoordinates = graph.transformKeyToCoordinates(\n      coordinatesAsKeys[Math.floor(Math.random() * coordinatesAsKeys.length)]\n    );\n    const targetCoordinates = [\n      ...graph.getCoordinatesAtSpecificDistance({\n        coordinates: possibleOpponentLocation,\n        distance: 3,\n      }),\n    ].filter(coordinates => {\n      return (\n        graph.getDistanceBetweenCoordinates(myLocation, coordinates) !== 0 &&\n        gameMap.isCellWalkable(coordinates)\n      );\n    });\n\n    let distance = Infinity;\n    let selectedCoordinates: ICoordinates = { x: 0, y: 0 };\n\n    for (let i = 0, iMax = targetCoordinates.length; i < iMax; i++) {\n      const targetDistance = graph.getDistanceBetweenCoordinates(myLocation, targetCoordinates[i]);\n\n      if (targetDistance < distance) {\n        distance = targetDistance;\n        selectedCoordinates = targetCoordinates[i];\n      }\n    }\n\n    const grid: PF.Grid = new PF.Grid(gameMap.getPathFindingWalkabilityMatrix());\n    const path: Array<Array<number>> = finder.findPath(\n      myLocation.x,\n      myLocation.y,\n      selectedCoordinates.x,\n      selectedCoordinates.y,\n      grid\n    );\n\n    if (path[1] === undefined) {\n      const { x, y } = possibleLocationsToMoveTo[0];\n      const vector = graph.createVectorFromCoordinates({ source: myLocation, target: { x, y } });\n      const direction = graph.transformVectorToDirection(vector);\n      return {\n        type: ECommand.MOVE,\n        utility: 0.3,\n        parameters: { direction, chargeCommand: 'TORPEDO' },\n      };\n    }\n\n    const [x, y] = path[1];\n\n    const vector = graph.createVectorFromCoordinates({ source: myLocation, target: { x, y } });\n    const direction = graph.transformVectorToDirection(vector);\n\n    return {\n      type: ECommand.MOVE,\n      utility: 0.3,\n      parameters: { direction, chargeCommand: 'TORPEDO' },\n    };\n  }\n}\n\nexport default MoveAction;\n","export * from './base-action';\nexport * from './torpedo';\nexport * from './surface';\nexport * from './move';\n","import PhantomSubmarineTracker from './phantom-submarine-tracker';\nimport MySubmarine from './my-submarine';\nimport { MoveAction, SurfaceAction, TorpedoAction, IWeightedAction } from './actions';\nimport { ECommand } from './command-interpreter';\n\nclass AI {\n  private torpedoAction: TorpedoAction;\n  private surfaceAction: SurfaceAction;\n  private moveAction: MoveAction;\n\n  constructor({\n    mySubmarine,\n    phantomSubmarineTracker,\n  }: {\n    mySubmarine: MySubmarine;\n    phantomSubmarineTracker: PhantomSubmarineTracker;\n  }) {\n    this.torpedoAction = new TorpedoAction({ mySubmarine, phantomSubmarineTracker });\n    this.surfaceAction = new SurfaceAction({ mySubmarine, phantomSubmarineTracker });\n    this.moveAction = new MoveAction({ mySubmarine, phantomSubmarineTracker });\n  }\n\n  static createInstance({\n    mySubmarine,\n    phantomSubmarineTracker,\n  }: {\n    mySubmarine: MySubmarine;\n    phantomSubmarineTracker: PhantomSubmarineTracker;\n  }): AI {\n    return new AI({ mySubmarine, phantomSubmarineTracker });\n  }\n\n  pickCommands(): IWeightedAction[] {\n    let maxUtility = -1;\n    let chosenAction = { type: ECommand.NA, utility: 0 };\n\n    const actionsToChoseFrom: IWeightedAction[] = [\n      this.torpedoAction.calculateUtility(),\n      this.surfaceAction.calculateUtility(),\n      this.moveAction.calculateUtility(),\n    ];\n\n    for (let i = 0, iMax = actionsToChoseFrom.length; i < iMax; i++) {\n      const { utility } = actionsToChoseFrom[i];\n\n      if (maxUtility < utility) {\n        maxUtility = utility;\n        chosenAction = actionsToChoseFrom[i];\n      }\n    }\n\n    return [chosenAction];\n  }\n}\n\nexport default AI;\n","import GameMap from './game-map';\nimport PhantomSubmarineTracker from './phantom-submarine-tracker';\nimport MySubmarine from './my-submarine';\nimport AI from './ai';\nimport commandInterpreter from './command-interpreter';\n\ndeclare const readline: any;\n\ntry {\n  const readNextLine = (): string => {\n    return readline();\n  };\n\n  const [width, height, myId] = readNextLine()\n    .split(' ')\n    .map(elem => {\n      return parseInt(elem, 10);\n    });\n\n  const gameMap = GameMap.createInstance({ width, height, sectorSize: 5 });\n  const phantomSubmarineTracker = PhantomSubmarineTracker.createInstance({ gameMap });\n  const mySubmarine = MySubmarine.createInstance({ gameMap });\n  const ai = AI.createInstance({ mySubmarine, phantomSubmarineTracker });\n\n  for (let y = 0; y < height; y++) {\n    const line: string = readNextLine();\n    const cells = [...line.split('')];\n\n    for (let x = 0; x < width; x++) {\n      const cell = cells[x];\n      gameMap.setCellTerrain({\n        terrain: GameMap.transformGameInputToTerrain(cell),\n        coordinates: { x, y },\n      });\n    }\n  }\n\n  const walkableCoordinates = gameMap.getWalkableCoordinates();\n  const mySubmarineStartingAt =\n    walkableCoordinates[Math.floor(Math.random() * walkableCoordinates.length)];\n\n  console.log(`${mySubmarineStartingAt.x} ${mySubmarineStartingAt.y}`);\n\n  // game loop\n  while (true) {\n    const [\n      x,\n      y,\n      myLife,\n      oppLife,\n      torpedoCooldown,\n      sonarCooldown,\n      silenceCooldown,\n      mineCooldown,\n    ] = readNextLine()\n      .split(' ')\n      .map(elem => {\n        return parseInt(elem, 10);\n      });\n\n    const sonarResult = readNextLine();\n    const opponentCommandsString = readNextLine();\n    const opponentCommands = commandInterpreter.transformCommandsStringToCommands(\n      opponentCommandsString\n    );\n\n    phantomSubmarineTracker.setOpponentLife(oppLife).processCommandsForSubmarines(opponentCommands);\n    mySubmarine.setState({\n      x,\n      y,\n      myLife,\n      torpedoCooldown,\n      sonarCooldown,\n      silenceCooldown,\n      mineCooldown,\n    });\n\n    const commandsStr = commandInterpreter.transformCommandsToCommandString({\n      commands: ai.pickCommands(),\n      mySubmarine,\n    });\n\n    console.log(commandsStr);\n  }\n} catch (error) {\n  console.error(error);\n}\n"]}